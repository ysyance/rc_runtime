/*
 * (c) 2003 Mario de Sousa
 *
 * Offered to the public under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 *
 * This code is made available on the understanding that it will not be
 * used in safety-critical situations without a full and competent review.
 */




/*
 * Code to be included into the code generated by the 4th stage.
 *
 * This is part of the 4th stage that generates
 * a ST and IL source program equivalent to the IL and ST
 * code.
 * This is expected to be used mainly in debuging the syntax
 * and lexical parser, and as a starting point for other
 * 4th stages.
 */






// #include <stdio.h>  /* required for NULL */
#include <cstring>
#include <iostream>
#include <cstdlib>
#include "generate_stmt_node.hh"

#include "../program_stage4.hh"
#include "../program_type.hh"
#include <cmath>

#include "../../data_stage4/data_stage4.hh"

namespace robot_program_file_process{


	//class generate_iec_c: public iterator_visitor_c {
	class generate_stmt_node: public visitor_c {
		private:
			robot_data_file_process::DEF_SYMTABLE &filename_symtable;
		public:
			generate_stmt_node(robot_data_file_process::DEF_SYMTABLE *variable_symtable):filename_symtable(*variable_symtable){}
			~generate_stmt_node(void) {}

		private:
			inline void *visit_list(list_c *list)
			{
				for(int i = 0; i < list->n; ++i)
				{
					list->elements[i] -> accept(*this);
				}
				return NULL;
			}


		public:

			/***************************/
			/* B 0 - Programming Model */
			/***************************/
			void *visit(library_c *symbol) { //Here should return statement head!
				if(symbol == NULL || symbol->statement_list_head == NULL)
				{
					std::cout << "library_c or library_c->statement_list_head is NULL" << std::endl;
					return NULL;
				}
				else
				{
					statement_node *program_head = static_cast<statement_node *>(symbol->statement_list_head->accept(*this));
					return static_cast<void *>(program_head);
				}
			} 

			/*******************************************/
			/* B 1.1 - Letters, digits and identifiers */
			/*******************************************/
			void *visit(identifier_c *symbol) {
				value_type *var = new value_type();
				if( var == NULL )
				{
					std::cout << "identifier_c|var : new memory failed !" << std::endl;
					return NULL;
				}
				var->v_type = TYPE_IDENTIFIER;
				char *cptr = new char[strlen(symbol->value)];
				if( cptr == NULL )
				{
					std::cout << "identifier_c|cptr : new memory failed !" << std::endl;
					return NULL;
				}
				strcpy(cptr, symbol->value);
				var->value.identifier = cptr;

				return static_cast<void *>(var);
			}

			/*********************/
			/* B 1.2 - Constants */
			/*********************/

			/******************************/
			/* B 1.2.1 - Numeric Literals */
			/******************************/
			void *visit(real_c *symbol) { 
				double *var = new double(atof(symbol->value)); 
				if( var == NULL )
				{
					std::cout << "real_c|var : new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(var);
			}
			void *visit(integer_c *symbol) { 
				int *var = new int(atoi(symbol->value)); 
				if( var == NULL )
				{
					std::cout << "integer_c|var : new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(var);
			}
			void *visit(neg_int_expression_c *symbol) 
			{
				int *var = static_cast<int *>(symbol->exp->accept(*this)); 
				*var = (*var) * (-1); 
				return static_cast<void *>(var);
			}
			void *visit(neg_real_expression_c *symbol) 
			{
				double *var = static_cast<double *>(symbol->exp->accept(*this)); 
				*var = (*var) * (-1); 
				return static_cast<void *>(var);
			}

			void *visit(integer_literal_c *symbol) {
				value_type *var = new value_type(); 
				if( var == NULL )
				{
					std::cout << "integer_literal_c|var : new memory failed !" << std::endl;
					return NULL;
				}
				var->v_type = TYPE_DINT; 
				var->value.dv = static_cast<int *>(symbol->value->accept(*this));
				return static_cast<void *>(var);
			}

			void *visit(real_literal_c *symbol) {
				value_type *var = new value_type(); 
				if( var == NULL )
				{
					std::cout << "real_literal_c|var : new memory failed !" << std::endl;
					return NULL;
				}
				var->v_type = TYPE_REAL; 
				var->value.rv = static_cast<double *>(symbol->value->accept(*this));
				return static_cast<void *>(var);
			}

			/* helper class for boolean_literal_c */
			void *visit(boolean_literal_c *symbol) {
				value_type *var = new value_type(); 
				if( var == NULL )
				{
					std::cout << "boolean_literal_c|var : new memory failed !" << std::endl;
					return NULL;
				}
				var->v_type = TYPE_BOOL; 
				var->value.bv = static_cast<bool *>(symbol->value->accept(*this));
				return static_cast<void *>(var);
			}

			void *visit(boolean_true_c *symbol) {
				bool *var = new bool(true);
				if( var == NULL )
				{
					std::cout << "boolean_true_c|var : new memory failed !" << std::endl;
					return NULL;
				} 
				return static_cast<void *>(var);
			}
			void *visit(boolean_false_c *symbol) {
				bool *var = new bool(false);
				if( var == NULL )
				{
					std::cout << "boolean_false_c|var : new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(var);
			}

			void *visit(character_string_c *symbol) {
				value_type *var = new value_type(); 
				if( var == NULL )
				{
					std::cout << "character_string_c|var : new memory failed !" << std::endl;
					return NULL;
				}
				var->v_type = TYPE_STRING; 
				var->value.sv = new std::string(symbol->value); //Attention here!
				return static_cast<void *>(var);
			}

			// B 1.3.1 - Elmentary Data Types
			void *visit(bool_type_name_c *symbol) {return NULL; }
			void *visit(dint_type_name_c *symbol) {return NULL;  }
			void *visit(real_type_name_c *symbol) {return NULL; }
			//void *visit(dword_type_name_c *symbol) {return NULL;  }
			void *visit(string_type_name_c *symbol) {return NULL;  }


			/***********************/
			/* B 3.1 - Expressions */
			/***********************/
			void *visit(or_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "or_expression_c|result :new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_BOOL;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "or_expression_c :lexp and rexp are NULL" << std::endl;
					return NULL;
				}
				bool lv = false, rv = false;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{// Be careful you should add { } here
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									lv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									if(*(expression_value->id_value.dv) != 0)
										lv = true;
									break;
								case robot_data_file_process::TYPE_REAL:
									if(*(expression_value->id_value.rv) != 0.0)
										lv = true;
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						lv = *(lexp->value.bv);
						break;
					case TYPE_DINT:
						if(*(lexp->value.dv))
							lv = true;
						break;
					case TYPE_REAL:
						if( *(lexp->value.rv))
							lv = true;
						break;
					default:
						std::cout << "or_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									rv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									if(*(expression_value->id_value.dv) != 0);
									rv = true;
									break;
								case robot_data_file_process::TYPE_REAL:
									if(*(expression_value->id_value.rv) != 0.0);
									rv = true;
									break;
								default:
									std::cout << "The type of right expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						rv = *(rexp->value.bv);
						break;
					case TYPE_DINT:
						if(*(rexp->value.dv))
							rv = true;
						break;
					case TYPE_REAL:
						if( *(rexp->value.rv))
							rv = true;
						break;
					default:
						std::cout << "or_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.bv = new bool(lv || rv);
				if( result->value.bv == NULL )
				{
					std::cout << "or_expression_c|result->value.bv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result);  
			}




			void *visit(and_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "and_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_BOOL;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "and_expression_c:lexp and rexp are NULL" << std::endl;
					return NULL;
				}
				bool lv = false, rv = false;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									lv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									if(*(expression_value->id_value.dv) != 0);
									lv = true;
									break;
								case robot_data_file_process::TYPE_REAL:
									if(*(expression_value->id_value.rv) != 0.0);
									lv = true;
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						lv = *(lexp->value.bv);
						break;
					case TYPE_DINT:
						if(*(lexp->value.dv))
							lv = true;
						break;
					case TYPE_REAL:
						if( *(lexp->value.rv))
							lv = true;
						break;
					default:
						std::cout << "and_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									rv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									if(*(expression_value->id_value.dv) != 0);
									rv = true;
									break;
								case robot_data_file_process::TYPE_REAL:
									if(*(expression_value->id_value.rv) != 0.0);
									rv = true;
									break;
								default:
									std::cout << "The type of right expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						rv = *(rexp->value.bv);
						break;
					case TYPE_DINT:
						if(*(rexp->value.dv))
							rv = true;
						break;
					case TYPE_REAL:
						if( *(rexp->value.rv))
							rv = true;
						break;
					default:
						std::cout << "and_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.bv = new bool(lv && rv);
				if( result->value.bv == NULL )
				{
					std::cout << "and_expression_c|result->value.bv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result);
			}




			void *visit(equ_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "equ_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_BOOL;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "equ_expression_c:lexp and rexp are NULL" << std::endl;
					return NULL;
				}
				double lv = 0, rv = 0;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									lv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									lv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									lv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						lv = *(lexp->value.bv);
						break;
					case TYPE_DINT:
						lv = *(lexp->value.dv);
						break;
					case TYPE_REAL:
						lv = *(lexp->value.rv);
						break;
					default:
						std::cout << "equ_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									rv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									rv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									rv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						rv = *(rexp->value.bv);
						break;
					case TYPE_DINT:
						rv = *(rexp->value.dv);
						break;
					case TYPE_REAL:
						rv = *(rexp->value.rv);
						break;
					default:
						std::cout << "equ_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.bv = new bool(lv == rv);
				if( result->value.bv == NULL )
				{
					std::cout << "equ_expression_c|result->value.bv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result);
			}




			void *visit(notequ_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "notequ_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_BOOL;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "notequ_expression_c:lexp and rexp are NULL" << std::endl;
					return NULL;
				}
				double lv = 0, rv = 0;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									lv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									lv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									lv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						lv = *(lexp->value.bv);
						break;
					case TYPE_DINT:
						lv = *(lexp->value.dv);
						break;
					case TYPE_REAL:
						lv = *(lexp->value.rv);
						break;
					default:
						std::cout << "notequ_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									rv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									rv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									rv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						rv = *(rexp->value.bv);
						break;
					case TYPE_DINT:
						rv = *(rexp->value.dv);
						break;
					case TYPE_REAL:
						rv = *(rexp->value.rv);
						break;
					default:
						std::cout << "notequ_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.bv = new bool(lv != rv);
				if( result->value.bv == NULL )
				{
					std::cout << "notequ_expression_c|result->value.bv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result);
			}




			void *visit(lt_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "lt_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_BOOL;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "lt_expression_c:lexp and rexp are NULL" << std::endl;
					return NULL;
				}
				double lv = 0, rv = 0;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									lv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									lv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									lv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						lv = *(lexp->value.bv);
						break;
					case TYPE_DINT:
						lv = *(lexp->value.dv);
						break;
					case TYPE_REAL:
						lv = *(lexp->value.rv);
						break;
					default:
						std::cout << "lt_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									rv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									rv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									rv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						rv = *(rexp->value.bv);
						break;
					case TYPE_DINT:
						rv = *(rexp->value.dv);
						break;
					case TYPE_REAL:
						rv = *(rexp->value.rv);
						break;
					default:
						std::cout << "lt_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.bv = new bool(lv < rv);
				if( result->value.bv == NULL )
				{
					std::cout << "lt_expression_c|result->value.bv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result); 
			}




			void *visit(gt_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "gt_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_BOOL;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "gt_expression_c:lexp and rexp are NULL" << std::endl;
					return NULL;
				}
				double lv = 0, rv = 0;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									lv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									lv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									lv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						lv = *(lexp->value.bv);
						break;
					case TYPE_DINT:
						lv = *(lexp->value.dv);
						break;
					case TYPE_REAL:
						lv = *(lexp->value.rv);
						break;
					default:
						std::cout << "gt_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									rv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									rv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									rv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						rv = *(rexp->value.bv);
						break;
					case TYPE_DINT:
						rv = *(rexp->value.dv);
						break;
					case TYPE_REAL:
						rv = *(rexp->value.rv);
						break;
					default:
						std::cout << "gt_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.bv = new bool(lv > rv);
				if( result->value.bv == NULL )
				{
					std::cout << "gt_expression_c|result->value.bv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result); 
			}




			void *visit(le_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "le_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_BOOL;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "le_expression_c:lexp and rexp are NULL" << std::endl;
					return NULL;
				}
				double lv = 0, rv = 0;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									lv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									lv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									lv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						lv = *(lexp->value.bv);
						break;
					case TYPE_DINT:
						lv = *(lexp->value.dv);
						break;
					case TYPE_REAL:
						lv = *(lexp->value.rv);
						break;
					default:
						std::cout << "le_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									rv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									rv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									rv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						rv = *(rexp->value.bv);
						break;
					case TYPE_DINT:
						rv = *(rexp->value.dv);
						break;
					case TYPE_REAL:
						rv = *(rexp->value.rv);
						break;
					default:
						std::cout << "le_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.bv = new bool(lv <= rv);
				if( result->value.bv == NULL )
				{
					std::cout << "le_expression_c|result->value.bv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result); 
			}



			void *visit(ge_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "ge_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_BOOL;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "ge_expression_c:lexp and rexp are NULL" << std::endl;
					return NULL;;
				}
				double lv = 0, rv = 0;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									lv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									lv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									lv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						lv = *(lexp->value.bv);
						break;
					case TYPE_DINT:
						lv = *(lexp->value.dv);
						break;
					case TYPE_REAL:
						lv = *(lexp->value.rv);
						break;
					default:
						std::cout << "ge_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									rv = *(expression_value->id_value.bv);
									break;
								case robot_data_file_process::TYPE_DINT:
									rv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									rv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						rv = *(rexp->value.bv);
						break;
					case TYPE_DINT:
						rv = *(rexp->value.dv);
						break;
					case TYPE_REAL:
						rv = *(rexp->value.rv);
						break;
					default:
						std::cout << "ge_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.bv = new bool(lv >= rv);
				if( result->value.bv == NULL )
				{
					std::cout << "ge_expression_c|result->value.bv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result);
			}



			void *visit(add_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "add_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_REAL;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "add_expression_c:lexp and rexp are NULL" << std::endl;
					return NULL;
				}
				double lv = 0, rv = 0;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_DINT:
									lv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									lv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_DINT:
						lv = *(lexp->value.dv);
						break;
					case TYPE_REAL:
						lv = *(lexp->value.rv);
						break;
					default:
						std::cout << "add_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_DINT:
									rv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									rv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_DINT:
						rv = *(rexp->value.dv);
						break;
					case TYPE_REAL:
						rv = *(rexp->value.rv);
						break;
					default:
						std::cout << "add_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.rv = new double(lv+rv);
				if( result->value.rv == NULL )
				{
					std::cout << "add_expression_c|result->value.rv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result);
			}



			void *visit(sub_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "sub_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_REAL;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "sub_expression_c:lexp and rexp are NULL" << std::endl;
					return NULL;
				}
				double lv = 0, rv = 0;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_DINT:
									lv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									lv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_DINT:
						lv = *(lexp->value.dv);
						break;
					case TYPE_REAL:
						lv = *(lexp->value.rv);
						break;
					default:
						std::cout << "sub_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_DINT:
									rv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									rv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_DINT:
						rv = *(rexp->value.dv);
						break;
					case TYPE_REAL:
						rv = *(rexp->value.rv);
						break;
					default:
						std::cout << "sub_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.rv = new double(lv-rv);
				if( result->value.rv == NULL )
				{
					std::cout << "sub_expression_c|result->value.rv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result);
			}


			void *visit(mul_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "mul_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_REAL;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "mul_expression_c:lexp and rexp are NULL" << std::endl;
					return NULL;
				}
				double lv = 0, rv = 0;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_DINT:
									lv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									lv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_DINT:
						lv = *(lexp->value.dv);
						break;
					case TYPE_REAL:
						lv = *(lexp->value.rv);
						break;
					default:
						std::cout << "mul_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_DINT:
									rv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									rv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_DINT:
						rv = *(rexp->value.dv);
						break;
					case TYPE_REAL:
						rv = *(rexp->value.rv);
						break;
					default:
						std::cout << "mul_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.rv = new double(lv*rv);
				if( result->value.rv == NULL )
				{
					std::cout << "mul_expression_c|result->value.rv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result);
			}




			void *visit(div_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "div_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_REAL;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "div_expression_c:lexp and rexp are NULL" << std::endl;
					return NULL;
				}
				double lv = 0, rv = 0;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_DINT:
									lv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									lv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_DINT:
						lv = *(lexp->value.dv);
						break;
					case TYPE_REAL:
						lv = *(lexp->value.rv);
						break;
					default:
						std::cout << "div_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_DINT:
									rv = *(expression_value->id_value.dv);
									break;
								case robot_data_file_process::TYPE_REAL:
									rv = *(expression_value->id_value.rv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_DINT:
						rv = *(rexp->value.dv);
						break;
					case TYPE_REAL:
						rv = *(rexp->value.rv);
						break;
					default:
						std::cout << "div_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.rv = new double(lv/rv);
				if( result->value.rv == NULL )
				{
					std::cout << "div_expression_c|result->value.rv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result);
			}




			void *visit(mod_expression_c *symbol) {
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "mod_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_DINT;
				value_type *lexp = static_cast<value_type *>(symbol->l_exp->accept(*this));
				value_type *rexp = static_cast<value_type *>(symbol->r_exp->accept(*this));
				if( lexp == NULL || rexp == NULL)
				{
					delete result;
					std::cout << "mod_expression_c:lexp and rexp are NULL" << std::endl;
					return NULL;
				}
				int lv = 0,rv = 0;
				switch(lexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(lexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_DINT:
									lv = *(expression_value->id_value.dv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_DINT:
						lv = *(lexp->value.dv);
						break;
					default:
						std::cout << "mod_expression_c|left expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				switch(rexp->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(rexp->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_DINT:
									rv = *(expression_value->id_value.dv);
									break;
								default:
									std::cout << "The type of left expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_DINT:
						rv = *(rexp->value.dv);
						break;
					default:
						std::cout << "mod_expression_c|right expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}

				result->value.dv = new int(lv%rv);
				if( result->value.dv == NULL )
				{
					std::cout << "mod_expression_c|result->value.dv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result);
			}




			void *visit(not_expression_c *symbol) {		
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "not_expression_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_BOOL;		
				value_type *val = static_cast<value_type *>(symbol->exp->accept(*this));
				if( val == NULL)
				{
					delete result;
					std::cout << "not_expression_c:exp are NULL" << std::endl;
					return NULL;
				}
				bool ret = false;
				switch(val->v_type)
				{
					case TYPE_IDENTIFIER:
						{
							robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(val->value.identifier);
							switch(*(expression_value->id_type))
							{
								case robot_data_file_process::TYPE_BOOL:
									ret = !(*(expression_value->id_value.bv));
									break;
								case robot_data_file_process::TYPE_DINT:
									ret = !(*(expression_value->id_value.dv));
									break;
								case robot_data_file_process::TYPE_REAL:
									ret = !(*(expression_value->id_value.rv));
									break;
								default:
									std::cout << "The type of  expression(variable) is wrong!" << std::endl;
									return NULL;
									break;
							}
						}
						break;
					case TYPE_BOOL:
						ret = !(*(val->value.bv));
					case TYPE_DINT:
						ret = !(*(val->value.dv));
						break;
					case TYPE_REAL:
						ret = !(*(val->value.rv));
						break;
					default:
						std::cout << "not_expression_c|expression: error type!" << std::endl;
						delete result;
						return NULL;
						break;
				}
				result->value.bv = new bool(ret);
				if( result->value.bv == NULL )
				{
					std::cout << "not_expression_c|result->value.bv: new memory failed !" << std::endl;
					return NULL;
				}
				return static_cast<void *>(result);  
			}




			void *visit(function_invocation_c *symbol) { //Here shoul be corrected!
				value_type *result = new value_type();
				if( result == NULL )
				{
					std::cout << "function_invocation_c|result: new memory failed !" << std::endl;
					return NULL;
				}
				result->v_type = TYPE_REAL;
				param_list *val = static_cast<param_list *>(symbol->parameter_assignment_list->accept(*this));

				if( val == NULL)
				{
					delete result;
					std::cout << "function_invocation_c:param_list are NULL" << std::endl;
					return NULL;
				}
				if(val->next == NULL)
				{
					double inpv = 0; 
					double ret = 0;
					switch(val->param->v_type)
					{
						case TYPE_IDENTIFIER:
							{
								robot_data_file_process::sym_element *expression_value =  filename_symtable.find_value(val->param->value.identifier);
								switch(*(expression_value->id_type))
								{
									case robot_data_file_process::TYPE_DINT:
										inpv = *(expression_value->id_value.dv);
										break;
									case robot_data_file_process::TYPE_REAL:
										inpv = *(expression_value->id_value.rv);
										break;
									default:
										std::cout << "The type of  parameter(variable) is wrong!" << std::endl;
										return NULL;
										break;
								}
							}
							break;
						case TYPE_DINT:
							inpv = *(val->param->value.dv);
							break;
						case TYPE_REAL:
							inpv = *(val->param->value.rv);
							break;
						default:
							std::cout << "function_invocation_c|param_list: error type!" << std::endl;
							delete result;
							return NULL;
							break;
					}
					value_type *fname = static_cast<value_type *>(symbol->function_name->accept(*this));
					const char *id = fname->value.identifier;
					if(!strcmp(id, "ABS"))
						ret = fabs(inpv);
					else if(!strcmp(id, "SQRT"))
						ret = sqrt(inpv);
					else if(!strcmp(id, "EXP"))
						ret = exp(inpv);
					else if(!strcmp(id, "SIN"))
						ret = sin(inpv);
					else if(!strcmp(id, "COS"))
						ret = cos(inpv);
					else if(!strcmp(id, "TAN"))
						ret = tan(inpv);
					else if(!strcmp(id, "ASIN"))
						ret = asin(inpv);
					else if(!strcmp(id, "ACOS"))
						ret = acos(inpv);
					else if(!strcmp(id, "ATAN"))
						ret = atan(inpv);
					else
					{
						std::cout << "function_invocation_c|id: error function type! " << std::endl;
						return NULL;
					}

					result->value.rv = new double(ret);
					if( result->value.rv == NULL )
					{
						std::cout << "function_invocation_c|result->value.rv: new memory failed !" << std::endl;
						return NULL;
					}
					return static_cast<void *>(result);
				}
				else
				{
					std::cout << "function_invocation_c|val: too many function input parameter !" << std::endl;
					return NULL;
				}
			}

			void *visit(param_assignment_list_c *symbol)
			{
				param_list *head = new param_list();
				if( head == NULL)
				{
					std::cout << "param_assignment_list_c|head: new memory failed !" << std::endl;
					return NULL;
				}
				head->param = static_cast<value_type *>(symbol->elements[0]->accept(*this));
				param_list *pre = head;
				param_list *next = NULL;
				value_type *param = NULL;
				for(int i = 1; i < symbol->n; ++i)
				{
					param = static_cast<value_type *>(symbol->elements[i] -> accept(*this));
					next = new param_list();
					if( next == NULL)
					{
						std::cout << "param_assignment_list_c|next: new memory failed !"  << std::endl;
						return NULL;
					}
					next->param = param;

					pre->next = next;
					pre = next;
				}
				return static_cast<void *>(head);
			}

			/********************/
			/* B 3.2 Statements */
			/********************/
			void *visit(statement_list_c *symbol) {
				if(symbol == NULL)
				{
					std::cout << "statement list is NULL in stage 4" << std::endl;
					return NULL;
				}
				else
				{
					if(symbol->n > 0)
					{
						std::cout << "statement list number is " << symbol->n << std::endl;
						statement_node *statement_list_head = static_cast<statement_node *>(symbol->elements[0] -> accept(*this));
						statement_node *pre = statement_list_head;
						statement_node *next = NULL;
						for(int i = 1; i < symbol->n; ++i)
						{
							next =static_cast<statement_node *>(symbol->elements[i] -> accept(*this));
							pre->next = next;
							pre = next;
						}
						return static_cast<void *>(statement_list_head);

					}
					else
					{
						std::cout << "statement list number is zero" << std::endl;
						return NULL;
					}
				}
			}

			/*********************************/
			/* B 3.2.1 Assignment Statements */
			/*********************************/
			void *visit( assignment_statement_c *symbol) {
				statement_node *snode = new statement_node();
				if( snode == NULL )
				{
					std::cout << "assignment_statement_c|snode: new memory failed !" << std::endl;
					return NULL;
				}
				snode->stmt_type = ST_ASSIGN;
				ASSIGN_STMT *astmt = new ASSIGN_STMT();
				if( astmt == NULL )
				{
					std::cout << "assignment_statement_c|astmt: new memory failed !" << std::endl;
					return NULL;
				}
				value_type *vartmp= static_cast<value_type *>(symbol->l_exp->accept(*this));
				astmt->variable = vartmp->value.identifier;
				astmt->value = static_cast<value_type *>(symbol->r_exp->accept(*this));
				snode->statement.assign_stmt = astmt;
				return static_cast<void *>(snode);
			}

			/*****************************************/
			/* B 3.2.2 Subprogram Control Statements */
			/*****************************************/
			void *visit( subprogram_invocation_c *symbol) {
				statement_node *snode = new statement_node();
				if( snode == NULL )
				{
					std::cout << "subprogram_invocation_c|snode: new memory failed !" << std::endl;
					return NULL;
				}
				snode->stmt_type = ST_CALL;
				CALL_STMT *cstmt = new CALL_STMT();
				if( cstmt == NULL )
				{
					std::cout << "subprogram_invocation_c|cstmt: new memory failed !" << std::endl;
					return NULL;
				}
				value_type *vartmp= static_cast<value_type *>(symbol->subprogram_name->accept(*this));
				cstmt->subprogram_name = vartmp->value.identifier;
				snode->statement.call_stmt = cstmt;
				return static_cast<void *>(snode);
			}


			/********************************/
			/* B 3.2.3 Selection Statements */
			/********************************/
			void *visit(if_statement_c *symbol) {
				statement_node *snode = new statement_node();
				if( snode == NULL )
				{
					std::cout << "if_statement_c|snode: new memory failed !" << std::endl;
					return NULL;
				}
				snode->stmt_type = ST_IF;
				IF_STMT *istmt = new IF_STMT();
				if( istmt == NULL )
				{
					std::cout << "if_statement_c|istmt: new memory failed !" << std::endl;
					return NULL;
				}
				istmt->condition = static_cast<value_type *>(symbol->expression->accept(*this));
				istmt->then_stmt = static_cast<statement_node *>(symbol->statement_list->accept(*this));
				if(symbol->elseif_statement_list == NULL)
				{
					std::cout << "elseif statement list is NULL in stage 4" << std::endl;
					istmt->elseif_stmt = NULL;
				}
				else
					istmt->elseif_stmt = static_cast<ELSEIF_STMT *>(symbol->elseif_statement_list->accept(*this));
				if(symbol->else_statement_list == NULL)
				{
					std::cout << "else statement is NULL in stage 4" << std::endl;
					istmt->else_stmt = NULL;
				}
				else

					istmt->else_stmt = static_cast<statement_node *>(symbol->else_statement_list->accept(*this));
				snode->statement.if_stmt = istmt;
				return static_cast<void *>(snode);
			}

			/* helper symbol for if_statement */
			void *visit(elseif_statement_list_c *symbol) {
				if(symbol->n == 0)
				{
					std::cout << "elseif statement list number is zero!" << std::endl;
					return NULL;
				}
				ELSEIF_STMT *elseif_head = static_cast<ELSEIF_STMT *>(symbol->elements[0] -> accept(*this));
				ELSEIF_STMT *pre = elseif_head;
				ELSEIF_STMT *next = NULL;
				for(int i = 1; i < symbol->n; ++i)
				{
					next = static_cast<ELSEIF_STMT *>(symbol->elements[i] -> accept(*this));
					pre->next = next;
					pre = next;
				}
				return static_cast<void *>(elseif_head);
			}

			/* helper symbol for elseif_statement_list */
			void *visit(elseif_statement_c *symbol) {
				ELSEIF_STMT *estmt = new ELSEIF_STMT();
				if( estmt == NULL )
				{
					std::cout << "elseif_statement_c|estmt: new memory failed !" << std::endl;
					return NULL;
				}
				estmt->condition = static_cast<value_type *>(symbol->expression->accept(*this));
				estmt->then_stmt = static_cast<statement_node *>(symbol->statement_list->accept(*this));
				return static_cast<void *>(estmt);
			}


			/********************************/
			/* B 3.2.4 Iteration Statements */
			/********************************/


			void *visit(while_statement_c *symbol) {
				statement_node *snode = new statement_node();
				if( snode == NULL )
				{
					std::cout << "while_statement_c|snode: new memory failed !" << std::endl;
					return NULL;
				}
				snode->stmt_type = ST_WHILE;
				WHILE_STMT *wstmt = new WHILE_STMT();
				if( wstmt == NULL )
				{
					std::cout << "while_statement_c|wstmt: new memory failed !" << std::endl;
					return NULL;
				}
				wstmt->condition = static_cast<value_type *>(symbol->expression->accept(*this));
				wstmt->stmt = static_cast<statement_node *>(symbol->statement_list->accept(*this));
				snode->statement.while_stmt = wstmt;
				return static_cast<void *>(snode);
			}

			void *visit(loop_statement_c *symbol) {
				statement_node *snode = new statement_node();
				if( snode == NULL )
				{
					std::cout << "loop_statement_c|snode: new memory failed !" << std::endl;
					return NULL;
				}
				snode->stmt_type = ST_LOOP;
				LOOP_STMT *lstmt = new LOOP_STMT();
				if( lstmt == NULL )
				{
					std::cout << "loop_statement_c|lstmt: new memory failed !" << std::endl;
					return NULL;
				}
				lstmt->const_expression = static_cast<value_type *>(symbol->const_expression->accept(*this));// Add value check here!
				lstmt->stmt = static_cast<statement_node *>(symbol->statement_list->accept(*this));
				snode->statement.loop_stmt = lstmt;
				return static_cast<void *>(snode);
			}

			/********************************/
			/* B 3.2.5 Robot Statements */
			/********************************/

			void *visit(robot_instruction_invocation_c *symbol) {
				statement_node *snode = new statement_node();
				if( snode == NULL )
				{
					std::cout << "robot_instruction_invocation_c|snode: new memory failed !" << std::endl;
					return NULL;
				}
				snode->stmt_type = ST_ROBOT;
				ROBOT_STMT *rstmt = new ROBOT_STMT();
				if( rstmt == NULL )
				{
					std::cout << "robot_instruction_invocation_c|rstmt: new memory failed !" << std::endl;
					return NULL;
				}
				value_type *ri_name = static_cast<value_type *>(symbol->robot_instruction_name->accept(*this));
				const char *rf = ri_name->value.identifier;
				if(!strcmp(rf, "PTP"))
					rstmt->ri_type = RT_PTP;
				else if(!strcmp(rf, "Lin"))
					rstmt->ri_type = RT_LIN;
				else if(!strcmp(rf, "Circ"))
					rstmt->ri_type = RT_CIRC;
				else if(!strcmp(rf, "Dyn"))
					rstmt->ri_type = RT_DYN;
				else if(!strcmp(rf, "DynOvr"))
					rstmt->ri_type = RT_DYNOVR;
				else if(!strcmp(rf, "Ovl"))
					rstmt->ri_type = RT_OVL;
				else if(!strcmp(rf, "Ramp"))
					rstmt->ri_type = RT_RAMP;
				else if(!strcmp(rf, "RefSys"))
					rstmt->ri_type = RT_REFSYS;
				else if(!strcmp(rf, "Tool"))
					rstmt->ri_type = RT_TOOL;
				else if(!strcmp(rf, "OriMode"))
					rstmt->ri_type = RT_ORIMODE;
				else if(!strcmp(rf, "WaitTime"))
					rstmt->ri_type = RT_WAITTIME;
				else if(!strcmp(rf, "Stop"))
					rstmt->ri_type = RT_STOP;
				else if(!strcmp(rf, "Info"))
					rstmt->ri_type = RT_INFO;
				else if(!strcmp(rf, "Warning"))
					rstmt->ri_type = RT_WARNING;
				else if(!strcmp(rf, "Error"))
					rstmt->ri_type = RT_ERROR;
				else
				{
					std::cout << "robot_instruction_invocation_c|rf: error robot instruction type! " << std::endl;
					return NULL;
				}
				rstmt->parameter_list = static_cast<param_list *>(symbol->parameter_assignment_list->accept(*this));

				snode->statement.robot_stmt = rstmt;
				return static_cast<void *>(snode);

			}

	}; /* class generate_stmt_node */


	/***********************************************************************/
	/***********************************************************************/
	/***********************************************************************/
	/***********************************************************************/
	/***********************************************************************/
	/***********************************************************************/
	/***********************************************************************/
	/***********************************************************************/


	visitor_c *new_stmt_node(robot_data_file_process::DEF_SYMTABLE *filename_symtable)  {return new generate_stmt_node(filename_symtable);}
	void delete_stmt_node(visitor_c *code_generator) {delete code_generator;}

}
