
/*************************************************************/
/*************************************************************/
/*File Description  : Robot Data files interpreter with flex */
/*Author            : Wang Zhen                              */
/*Create Date       : 2014.06.10                             */
/*Last Update       : 2014.07.01                             */
/*************************************************************/
/*************************************************************/

/******************************************/
/******************************************/
/*Section 01  : Definitions...            */
/*Author      : Wang Zhen                 */
/*Create Date : 2014.06.10                */
/*Last Update : 2014.07.01                */
/******************************************/
/******************************************/

/******************************************/
/*Part 0101   : Lexical Parser Options... */
/*Author      : Wang Zhen                 */
/*Create Date : 2014.06.10                */
/*Last Update : 2014.07.01                */
/******************************************/

/* The lexical analyser will never work in interactive mode,
 * i.e., it will only process programs saved to files, and never
 * programs being written inter-actively by the user.
 * This option saves the resulting parser from calling the
 * isatty() function, that seems to be generating some compile
 * errors under some (older?) versions of flex.
 */
%option never-interactive

/* Have the lexical analyser use a 'char *yytext' instead of an
 * array of char 'char yytext[??]' to store the lexical token.
 */
%pointer

/* Have the generated lexical analyser keep track of the
 * line number it is currently analysing.
 * This is used to pass up to the syntax parser
 * the number of the line on which the current
 * token was found. It will enable the syntax parser
 * to generate more informatve error messages...
 */

%option prefix = "data_yy"

%option yylineno

/***************************************************************/
/*Part 0102   : External Variable and Function declarations... */
/*Author      : Wang Zhen                                      */
/*Create Date : 2014.06.10                                     */
/*Last Update : 2014.07.01                                     */
/***************************************************************/

%{

/* Define TEST_MAIN to include a main() function.
 * Useful for testing the parser generated by flex.
 */
/*#define TEST_MAIN*/

/* Required for strdup() */
#include <string.h>

/* Required only for the declaration of abstract syntax classes
 * (class symbol_c; class token_c; class list_c;)
 * These will not be used in flex, but the token type union defined
 * in ro.tab.h contains pointers to these classes, so we must include
 * it here.
 */
#include "../data_absyntax/data_absyntax.hh"

/* generated by bison.
 * Contains the definition of the token constants, and the
 * token value type YYSTYPE (in our case, a 'const char *')
 */
#include "ro.y.hh"

/* Variable defined by the bison parser,
 * where the value of the tokens will be stored
 */
extern YYSTYPE data_yylval;

/* The name of the file currently being parsed...
 * This variable is declared and read from the code generated by bison!
 */
extern const char *data_current_filename;

#define YY_NO_UNPUT

/* Variable defined by the bison parser.
 * It must be initialised with the location
 * of the token being parsed.
 * This is only needed if we want to keep
 * track of the locations, in order to give
 * more meaningful error messages!
 */
/*
extern YYLTYPE yylloc;
*/
/* Macro that is executed for every action.
 * We use it to pass the location of the token
 * back to the bison parser...
 */
/*
#define YY_USER_ACTION { 					\
	yylloc.first_line = yylloc.last_line = yylineno;	\
	yylloc.first_column = yylloc.last_column = 0;		\
	}
 */
%}

/******************************************/
/*Part 0103   : Prelimenary constructs... */
/*Author      : Wang Zhen                 */
/*Create Date : 2014.06.10                */
/*Last Update : 2014.07.10                */
/******************************************/

        

/*****************************/
/*  Whitespace and comments... */
/*****************************/

whitespace [ \n\r\t\v]*

/*****************************************/
/* B.1.1 Letters, digits and identifiers */
/*****************************************/

letter           [A-Za-z]
digit            [0-9]
octal_digit      [0-7]
hex_digit        {digit}|[A-F]
identifier	 ({letter}|(_({letter}|{digit})))((_?({letter}|{digit}))*)

/*******************/
/* B.1.2 Constants */
/*******************/

/******************************/
/* B.1.2.1   Numeric literals */
/******************************/
integer          {digit}+
bit		 [0-1]
binary_integer   2#{bit}({bit}*)
octal_integer   8#{octal_digit}((_?{octal_digit})*)
hex_integer     16#{hex_digit}((_?{hex_digit})*)
EXP	         [Ee]([-+]?){integer}
real	         {integer}\.{integer}{EXP}?

/*******************************/
/* B.1.2.2   Character Strings */
/*******************************/
esc_char_u		$L|$N|$P|$R|$T
esc_char_l		$l|$n|$p|$r|$t
esc_char		$$|{esc_char_u}|{esc_char_l}
single_byte_char	(${hex_digit}{hex_digit})
/* WARNING:
 * This definition is only valid in ASCII...
 *
 * Flex includes the function print_char() that defines
 * all printable characters portably (i.e. whatever character
 * encoding is currently being used , ASCII, EBCDIC, etc...)
 * Unfortunately, we cannot generate the definition of
 * common_character_representation portably, since flex
 * does not allow definition of sets by subtracting
 * elements in one set from another set.
 * This means we must build up the defintion of
 * common_character_representation using only set addition,
 * which leaves us with the only choice of defining the
 * characters non-portably...
 */
common_character_representation		[\x20\x21\x23\x25\x26\x28-\x7E]|{esc_char}
character_representation 	        $'|\"|{single_byte_char}|{common_character_representation}
character_string	                \"({character_representation}*)\"


%%
       /*ATTENTION PLEASE! Comments should not be placed */
       /*at the first of lines!*/
       /*ATTENTION PLEASE! Comments should not be //! */
       /******************************************/
       /******************************************/
       /*Section 02  : Rules...                  */
       /*Author      : Wang Zhen                 */
       /*Create Date : 2014.06.10                */
       /*Last Update : 2014.07.10                */
       /******************************************/
       /******************************************/



       /******************************************/
       /******************************************/
       /******************************************/
       /******************************************/
       /*Part 0201   : First things first        */
       /*Author      : Wang Zhen                 */
       /*Create Date : 2014.06.10                */
       /*Last Update : 2014.07.10                */
       /******************************************/
       /******************************************/
       /******************************************/
       /******************************************/

	/*********************************/
	/* Handle all the state changes! */
	/*********************************/

	/***************************************/
	/* Next is to to remove all whitespace */
	/***************************************/

{whitespace}   /* Eat any whitespace */







      /******************************************/
      /******************************************/
      /******************************************/
      /******************************************/
      /*Part 0202   : keywords...               */
      /*Author      : Wang Zhen                 */
      /*Create Date : 2014.06.10                */
      /*Last Update : 2014.07.10                */
      /******************************************/
      /******************************************/
      /******************************************/
      /******************************************/

        /******************************/
	/* B 1.2.1 - Numeric Literals */
	/******************************/
TRUE              return TRUE;
FALSE             return FALSE;
     	/***********************************/
	/* B 1.3.1 - Elementary Data Types */
	/***********************************/
BOOL              return BOOL;
DINT              return DINT;
REAL              return REAL;
STRING            return STRING;
        /*DWORD             return DWORD;*/

        /******************************/
	/* B 1.3.2 - Robot Data Types */
	/******************************/
     /*Position data types */
AXISPOS           return AXISPOS;
CARTPOS           return CARTPOS;
       /*AXISPOSEXT        return AXISPOSEXT;*/
       /*CARTPOSEXT	  return CARTPOSEXT;*/
ROBAXISPOS  	  return ROBAXISPOS;
AUXAXISPOS	  return AUXAXISPOS;
ROBCARTPOS	  return ROBCARTPOS;

    /*Reference system data types*/
    /*WORLDREFSYS  	  return WORLDREFSYS;
CARTREFSYS	  return CARTREFSYS;
   /*CARTREFSYSEXT	  return CARTREFSYSEXT;*/
   /*CARTREFSYSAXIS    return CARTREFSYSAXIS;*/
       
       /*Tool data types*/ 
TOOL		  return TOOL;
   /*TOOLSTATIC	  return TOOLSTATIC;*/

       /*Overlapping data types*/ 
OVLREL		  return OVLREL;
OVLABS		  return OVLABS;

      /*Dynamic data types*/
DYNAMIC		  return DYNAMIC;
      /* World reference system */
      /* World  		  return WORLD;*/
     /* Percentage */
PERCENT           return PERCENT;
PERC200           return PERC200;

	/********************************/
	/* B 1.3.3 - Derived data types */
	/********************************/
"="              return ASSIGN;








        /******************************************/
        /******************************************/
        /******************************************/
        /******************************************/
        /*Part 0203   : Values...                 */
        /*Author      : Wang Zhen                 */
        /*Create Date : 2014.06.10                */
        /*Last Update : 2014.07.10                */
        /******************************************/
        /******************************************/
        /******************************************/
        /******************************************/

	/*****************************************/
	/* B 1.1 Identifiers                     */
	/*****************************************/
{identifier} 	{
		   data_yylval.ID=strdup(data_yytext);
		   return identifier_token;
		}
	/******************************/
	/* B.1.2.1   Numeric literals */
	/******************************/

{integer}               {data_yylval.ID=strdup(data_yytext); return integer_token;}
{real}		        {data_yylval.ID=strdup(data_yytext); return real_token;}
         /* {binary_integer}	{data_yylval.ID=strdup(data_yytext);      
            return   binary_integer_token;}*/
         /* {octal_integer} 	{data_yylval.ID=strdup(data_yytext); 
                return octal_integer_token;}*/
         /* {hex_integer} 		{data_yylval.ID=strdup(data_yytext); 
             return hex_integer_token;}*/

	/*******************************/
	/* B.1.2.2   Character Strings */
	/*******************************/
{character_string}      {data_yylval.ID=strdup(data_yytext); return character_string_token;}

        /* The end of the file ... */
<<EOF>>         {yyterminate();}








      /******************************************/
      /******************************************/
      /******************************************/
      /******************************************/
      /*Part 0204   : The leftovers...          */
      /*Author      : Wang Zhen                 */
      /*Create Date : 2014.06.10                */
      /*Last Update : 2014.07.10                */
      /******************************************/
      /******************************************/
      /******************************************/
      /******************************************/


     /* do the single character tokens...
      *  e.g.:  ':'  '('  ')'  ','  '+' '-' ...
      */


.	       {return data_yytext[0];}







%%

/******************************************/
/******************************************/
/*Section 03  : User Code...              */
/*Author      : Wang Zhen                 */
/*Create Date : 2014.06.10                */
/*Last Update : 2014.07.01                */
/******************************************/
/******************************************/

/*************************************************/
/*Part 0301   : Utility function definitions...  */
/*Author      : Wang Zhen                        */
/*Create Date : 2014.06.10                       */
/*Last Update : 2014.07.01                       */
/*************************************************/

/* Called by flex when it reaches the end-of-file */
int yywrap(void)
{
  /* We reached the end of the input file... */

  /* Should we continue with another file? */
  /* If so:
   *   open the new file...
   *   return 0;
   */

  /* to we stop processing...
   *
   *   return 1;
   */


  return 1;  /* Stop scanning at end of input file. */
}

